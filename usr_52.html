---
layout: vimdoc
helpname: 'usr_52'
---
<div id='vimCodeElement'>
<a class="Constant" href="usr_52.html" name="usr_52.txt">usr_52.txt</a>&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim version 8.2.</span>&nbsp;&nbsp;Last change: 2022 Jun 03<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIM USER MANUAL - by Bram Moolenaar<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write larger plugins<br>
<br>
TODO: this file needs to be updated<br>
<br>
When plugins do more than simple things, they tend to grow big.&nbsp;&nbsp;This file<br>
explains how to make sure they still load fast and how to split them up in<br>
smaller parts<br>
<br>
<a class="Identifier" href="usr_52.html#52.1">52.1</a>&nbsp;&nbsp;Export and import<br>
<a class="Identifier" href="usr_52.html#52.2">52.2</a>&nbsp;&nbsp;Autoloading<br>
<a class="Identifier" href="usr_52.html#52.3">52.3</a>&nbsp;&nbsp;Autoloading without import/export<br>
<a class="Identifier" href="usr_52.html#52.4">52.4</a>&nbsp;&nbsp;Other mechanisms to use<br>
<a class="Identifier" href="usr_52.html#52.5">52.5</a>&nbsp;&nbsp;Using a Vim9 script from legacy script<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; Next chapter:&nbsp;<a class="Identifier" href="usr_90.html">usr_90.txt</a>&nbsp;&nbsp;Installing Vim<br>
&nbsp;Previous chapter:&nbsp;<a class="Identifier" href="usr_51.html">usr_51.txt</a>&nbsp;&nbsp;Create a plugin<br>
Table of contents:&nbsp;<a class="Identifier" href="usr_toc.html">usr_toc.txt</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.1" name="52.1">52.1</a>&nbsp;&nbsp;Export and import<br>
<br>
Vim9 script was designed to make it easier to write large Vim scripts.&nbsp;&nbsp;It<br>
looks more like other script languages, especially Typescript.&nbsp;&nbsp;Also,<br>
functions are compiled into instructions that can be executed quickly.&nbsp;&nbsp;This<br>
makes Vim9 script a lot faster, up to a 100 times.<br>
<br>
The basic idea is that a script file has items that are private, only used<br>
inside the script file, and items that are exported, used outside of the<br>
script file.&nbsp;&nbsp;The exported items can then be used by scripts that import them.<br>
That makes very clear what is defined where.<br>
<br>
Let's start with an example, a script that exports one function and has one<br>
private function:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script&nbsp;&nbsp;&quot; This indicates a Vim9 script file.</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export def GetMessage(): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let result = ''<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = GetPart(count)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def GetPart(nr: number): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nr == 4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'yes'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'no'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
The&nbsp;<a class="Comment" href="vim9.html#vim9script">vim9script</a>&nbsp;command must be the very first command in the file.&nbsp;&nbsp;Without<br>
it Vim will assume legacy script syntax.<br>
<br>
The&nbsp;<span class="Comment">export def GetMessage(): string</span>&nbsp;line starts with&nbsp;<a class="Comment" href="vim9.html#:export">export</a>, meaning that<br>
this function can be imported and called by other scripts. The line<br>
<span class="Comment">def GetPart(...</span>&nbsp;does not start with&nbsp;<a class="Comment" href="vim9.html#:export">export</a>, this is a script-local<br>
function, it can only be used inside this script file.<br>
<br>
In the&nbsp;<span class="Comment">export def GetMessage(): string</span>&nbsp;line you will notice the colon and<br>
the return type.&nbsp;&nbsp;Vim9 functions, defined with&nbsp;<a class="Comment" href="vim9.html#:def">def</a>, require specifying the<br>
type of arguments and the return type.&nbsp;&nbsp;That way Vim can compile the code<br>
efficiently.&nbsp;&nbsp;The GetPart function defines an argument &quot;nr&quot; of type &quot;number&quot;.<br>
<br>
TODO: import/export example<br>
<br>
USING GLOBALS<br>
<br>
Sometimes you will want to use global variables or functions, so that they can<br>
be used anywhere.&nbsp;&nbsp;A good example is a global variable that passes a<br>
preference to a plugin.&nbsp;&nbsp;To avoid other scripts using the same name, use a<br>
prefix that is very unlikely to be used elsewhere.&nbsp;&nbsp;For example, if you have a<br>
&quot;mytags&quot; plugin, you could use:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:mytags_location = '$HOME/project'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:mytags_style = 'fast'</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.2" name="52.2">52.2</a>&nbsp;&nbsp;Autoloading<br>
<br>
TODO: autoloading with import/export<br>
<br>
After splitting your large script into pieces, all the lines will still be<br>
loaded and executed the moment the script is used.&nbsp;&nbsp;Every&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;loads the<br>
imported script to find the items defined there.&nbsp;&nbsp;Although that is good for<br>
finding errors early, it also takes time.&nbsp;&nbsp;Which is wasted if the<br>
functionality is not often used.<br>
<br>
Instead of having&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;load the script immediately, it can be postponed<br>
until needed.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import autoload &quot;./LoadLater.vim&quot;</div>
<br>
Now you can use exported items as usual: &quot;LoadLater.GetMonth(4)&quot;.<br>
However, the type will not be checked. Not even the existence of the<br>
GetMonth() function is checked until it is used.&nbsp;&nbsp;You will have to decide what<br>
is more important for your script.&nbsp;&nbsp;You can also add the &quot;autoload&quot; argument<br>
later, after you have checked everything works.<br>
<br>
Another form is to use a script name that is not an absolute or relative<br>
path:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import autload &quot;monthlib.vim&quot;</div>
<br>
This will search for the script &quot;monthlib.vim&quot; in the autoload directories of<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>.&nbsp;&nbsp;With Unix the directory often is &quot;~/.vim/autoload&quot;.<br>
<br>
The main advantage of this is that this script can be shared with other<br>
scripts.&nbsp;&nbsp;You do need to make sure that the script name is unique, since Vim<br>
will search all the &quot;autoload&quot; directories in&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>, and if you are<br>
using several plugins, these may add several directories to&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>,<br>
each of which might have an &quot;autoload&quot; directory.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.3" name="52.3">52.3</a>&nbsp;&nbsp;Autoloading without import/export<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#write-library-script" name="write-library-script">write-library-script</a><br>
A mechanism from before import/export is still useful and some users may find<br>
it a bit simpler.&nbsp;&nbsp;The idea is that you call a function with a special name.<br>
That function is then in an autoload script.&nbsp;&nbsp;We will call that one script a<br>
library script.<br>
<br>
The autoload mechanism is based on a funtion name that has &quot;#&quot; characters:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mylib#myfunction(arg)</div>
<br>
Vim will recognize the function name by the embedded &quot;#&quot; character and when<br>
it is not defined yet search for the script &quot;autoload/mylib.vim&quot; in<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>.&nbsp;&nbsp;That script must define the &quot;mylib#myfunction()&quot; function.<br>
Obviously the name &quot;mylib&quot; is the part before the &quot;#&quot; and is used as the name<br>
of the script, adding &quot;.vim&quot;.<br>
<br>
You can put many other functions in the mylib.vim script, you are free to<br>
organize your functions in library scripts.&nbsp;&nbsp;But you must use function names<br>
where the part before the '#' matches the script name.&nbsp;&nbsp;Otherwise Vim would<br>
not know what script to load.&nbsp;&nbsp;This is where it differs from the import/export<br>
mechanism.<br>
<br>
If you get really enthusiastic and write lots of library scripts, you may<br>
want to use subdirectories.&nbsp;&nbsp;Example:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netlib#ftp#read('somefile')</div>
<br>
Here the script name is taken from the function name up to the last &quot;#&quot;. The<br>
&quot;#&quot; in the middle are replaced by a slash, the last one by &quot;.vim&quot;.&nbsp;&nbsp;Thus you<br>
get &quot;netlib/ftp.vim&quot;.&nbsp;&nbsp;For Unix the library script used for this could be:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~/.vim/autoload/netlib/ftp.vim<br>
<br>
Where the function is defined like this:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def netlib#ftp#read(fname: string)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;Read the file fname through ftp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
Notice that the name the function is defined with is exactly the same as the<br>
name used for calling the function.&nbsp;&nbsp;And the part before the last '#'<br>
exactly matches the subdirectory and script name.<br>
<br>
You can use the same mechanism for variables:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var weekdays = dutch#weekdays</div>
<br>
This will load the script &quot;autoload/dutch.vim&quot;, which should contain something<br>
like:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ 'donderdag', 'vrijdag', 'zaterdag']</div>
<br>
Further reading:&nbsp;<a class="Identifier" href="eval.html#autoload">autoload</a>.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.4" name="52.4">52.4</a>&nbsp;&nbsp;Other mechanisms to use<br>
<br>
Some may find the use of several files a hassle and prefer to keep everything<br>
together in one script.&nbsp;&nbsp;To avoid this resulting in slow startup there is a<br>
mechanism that only defines a small part and postpones the rest to when it is<br>
actually used.&nbsp;&nbsp;<a class="Constant" href="usr_52.html#write-plugin-quickload" name="write-plugin-quickload">write-plugin-quickload</a><br>
<br>
The basic idea is that the plugin is loaded twice.&nbsp;&nbsp;The first time user<br>
commands and mappings are defined that offer the functionality.&nbsp;&nbsp;The second<br>
time the functions that implement the functionality are defined.<br>
<br>
It may sound surprising that quickload means loading a script twice.&nbsp;&nbsp;What we<br>
mean is that it loads quickly the first time, postponing the bulk of the<br>
script to the second time, which only happens when you actually use it.&nbsp;&nbsp;When<br>
you always use the functionality it actually gets slower!<br>
<br>
This uses a FuncUndefined autocommand.&nbsp;&nbsp;This works differently from the<br>
<a class="Identifier" href="eval.html#autoload">autoload</a>&nbsp;functionality explained above.<br>
<br>
The following example shows how it's done:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Vim global plugin for demonstrating quick loading<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Last Change:&nbsp;&nbsp;2005 Feb 25<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;s:did_load&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=* BNRead&nbsp;&nbsp;call BufNetRead(&lt;f-args&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let s:did_load = 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exe 'au FuncUndefined BufNet* source ' .. expand('&lt;sfile&gt;')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetRead(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetRead(' .. string(a:000) .. ')'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; read functionality here<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetWrite(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetWrite(' .. string(a:000) .. ')'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; write functionality here<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</div>
<br>
When the script is first loaded &quot;s:did_load&quot; is not set.&nbsp;&nbsp;The commands between<br>
the &quot;if&quot; and &quot;endif&quot; will be executed.&nbsp;&nbsp;This ends in a&nbsp;<a class="Identifier" href="repeat.html#:finish">:finish</a>&nbsp;command, thus<br>
the rest of the script is not executed.<br>
<br>
The second time the script is loaded &quot;s:did_load&quot; exists and the commands<br>
after the &quot;endif&quot; are executed.&nbsp;&nbsp;This defines the (possible long)<br>
BufNetRead() and BufNetWrite() functions.<br>
<br>
If you drop this script in your plugin directory Vim will execute it on<br>
startup.&nbsp;&nbsp;This is the sequence of events that happens:<br>
<br>
1. The &quot;BNRead&quot; command is defined and the&nbsp;<span class="Special">&lt;F19&gt;</span>&nbsp;key is mapped when the script<br>
&nbsp;&nbsp; is sourced at startup.&nbsp;&nbsp;A&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;autocommand is defined.&nbsp;&nbsp;The<br>
&nbsp;&nbsp; &quot;:finish&quot; command causes the script to terminate early.<br>
<br>
2. The user types the BNRead command or presses the&nbsp;<span class="Special">&lt;F19&gt;</span>&nbsp;key.&nbsp;&nbsp;The<br>
&nbsp;&nbsp; BufNetRead() or BufNetWrite() function will be called.<br>
<br>
3. Vim can't find the function and triggers the&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;autocommand<br>
&nbsp;&nbsp; event.&nbsp;&nbsp;Since the pattern &quot;BufNet*&quot; matches the invoked function, the<br>
&nbsp;&nbsp; command &quot;source fname&quot; will be executed.&nbsp;&nbsp;&quot;fname&quot; will be equal to the name<br>
&nbsp;&nbsp; of the script, no matter where it is located, because it comes from<br>
&nbsp;&nbsp; expanding &quot;<span class="Special">&lt;sfile&gt;</span>&quot; (see&nbsp;<a class="Identifier" href="builtin.html#expand()">expand()</a>).<br>
<br>
4. The script is sourced again, the &quot;s:did_load&quot; variable exists and the<br>
&nbsp;&nbsp; functions are defined.<br>
<br>
Notice that the functions that are loaded afterwards match the pattern in the<br>
<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;autocommand.&nbsp;&nbsp;You must make sure that no other plugin defines<br>
functions that match this pattern.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.5" name="52.5">52.5</a>&nbsp;&nbsp;Using a Vim9 script from legacy script&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#source-vim9-script" name="source-vim9-script">source-vim9-script</a><br>
<br>
In some cases you have a legacy Vim script where you want to use items from a<br>
Vim9 script.&nbsp;&nbsp;For example in your .vimrc you want to initialize a plugin.&nbsp;&nbsp;The<br>
best way to do this is to use&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>.&nbsp;&nbsp;For example:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import Init as NiceInit from 'myNicePlugin.vim'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call NiceInit('today')</div>
<br>
This finds the exported function &quot;Init&quot; in the Vim9 script file and makes it<br>
available as script-local item &quot;NiceInit&quot;.&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;always uses the script<br>
namespace, even when &quot;s:&quot; is not given.&nbsp;&nbsp;If &quot;myNicePlugin.vim&quot; was already<br>
sourced it is not sourced again.<br>
<br>
Besides avoiding putting any items in the global namespace (where name clashes<br>
can cause unexpected errors), this also means the script is sourced only once,<br>
no matter how many times items from it are imported.<br>
<br>
In some cases, e.g. for testing, you may just want to source the Vim9 script.<br>
That is OK, but then only global items will be available.&nbsp;&nbsp;The Vim9 script<br>
will have to make sure to use a unique name for these global items. Example:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source ~/.vim/extra/myNicePlugin.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call g:NicePluginTest()</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
Next chapter:&nbsp;<a class="Identifier" href="usr_90.html">usr_90.txt</a>&nbsp;&nbsp;Installing Vim<br>
<br>
<br>
Copyright: see&nbsp;<a class="Identifier" href="usr_01.html#manual-copyright">manual-copyright</a>&nbsp;&nbsp;vim:tw=78:ts=8:noet:ft=help:norl:<br>
</div>
