---
layout: vimdoc
helpname: 'usr_52'
---
<div id='vimCodeElement'>
<a class="Constant" href="usr_52.html" name="usr_52.txt">usr_52.txt</a>&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim version 9.1.</span>&nbsp;&nbsp;Last change: 2024 May 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIM USER MANUAL - by Bram Moolenaar<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write larger plugins<br>
<br>
When plugins do more than simple things, they tend to grow big.&nbsp;&nbsp;This file<br>
explains how to make sure they still load fast and how to split them up in<br>
smaller parts.<br>
<br>
<a class="Identifier" href="usr_52.html#52.1">52.1</a>&nbsp;&nbsp;Export and import<br>
<a class="Identifier" href="usr_52.html#52.2">52.2</a>&nbsp;&nbsp;Autoloading<br>
<a class="Identifier" href="usr_52.html#52.3">52.3</a>&nbsp;&nbsp;Autoloading without import/export<br>
<a class="Identifier" href="usr_52.html#52.4">52.4</a>&nbsp;&nbsp;Other mechanisms to use<br>
<a class="Identifier" href="usr_52.html#52.5">52.5</a>&nbsp;&nbsp;Using a Vim9 script from legacy script<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; Next chapter:&nbsp;<a class="Identifier" href="usr_90.html">usr_90.txt</a>&nbsp;&nbsp;Installing Vim<br>
&nbsp;Previous chapter:&nbsp;<a class="Identifier" href="usr_51.html">usr_51.txt</a>&nbsp;&nbsp;Create a plugin<br>
Table of contents:&nbsp;<a class="Identifier" href="usr_toc.html">usr_toc.txt</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.1" name="52.1">52.1</a>&nbsp;&nbsp;Export and import<br>
<br>
Vim9 script was designed to make it easier to write large Vim scripts.&nbsp;&nbsp;It<br>
looks more like other script languages, especially Typescript.&nbsp;&nbsp;Also,<br>
functions are compiled into instructions that can be executed quickly.&nbsp;&nbsp;This<br>
makes Vim9 script a lot faster, up to a 100 times.<br>
<br>
The basic idea is that a script file has items that are private, only used<br>
inside the script file, and items that are exported, which can be used by<br>
scripts that import them.&nbsp;&nbsp;That makes very clear what is defined where.<br>
<br>
Let's start with an example, a script that exports one function and has one<br>
private function:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export def GetMessage(count: string): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var nr = str2nr(count)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var result = $'To {nr} we say '<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result ..= GetReply(nr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def GetReply(nr: number): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if nr == 42<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'yes'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elseif nr == 22<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'maybe'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 'no'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
The&nbsp;<a class="Comment" href="vim9.html#vim9script">vim9script</a>&nbsp;command is required,&nbsp;<a class="Comment" href="vim9.html#:export">export</a>&nbsp;only works in a&nbsp;<a class="Identifier" href="vim9.html#Vim9">Vim9</a>&nbsp;script.<br>
<br>
The&nbsp;<span class="Comment">export def GetMessage(...</span>&nbsp;line starts with&nbsp;<a class="Comment" href="vim9.html#:export">export</a>, meaning that this<br>
function can be called by other scripts.&nbsp;&nbsp;The line&nbsp;<span class="Comment">def GetReply(...</span>&nbsp;does not<br>
start with&nbsp;<a class="Comment" href="vim9.html#:export">export</a>, this is a script-local function, it can only be used<br>
inside this script file.<br>
<br>
Now about the script where this is imported.&nbsp;&nbsp;In this example we use this<br>
layout, which works well for a plugin below the &quot;pack&quot; directory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../plugin/theplugin.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../lib/getmessage.vim<br>
<br>
Assuming the &quot;...&quot; directory has been added to&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>, Vim will look<br>
for plugins in the &quot;plugin&quot; directory and source &quot;theplugin.vim&quot;.&nbsp;&nbsp;Vim does<br>
not recognize the &quot;lib&quot; directory, you can put any scripts there.<br>
<br>
The above script that exports GetMessage() goes in lib/getmessage.vim.&nbsp;&nbsp;The<br>
GetMessage() function is used in plugin/theplugin.vim:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import &quot;../lib/getmessage.vim&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=1 ShowMessage echomsg getmessage.GetMessage(&lt;f-args&gt;)</div>
<br>
The&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;command uses a relative path, it starts with &quot;../&quot;, which means<br>
to go one directory up.&nbsp;&nbsp;For other kinds of paths see the&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;command.<br>
<br>
How we can try out the command that the plugin provides:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowMessage 1</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">To 1 we say no</span><br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShowMessage 22</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">To 22 we say maybe</span><br>
<br>
Notice that the function GetMessage() is prefixed with the imported script<br>
name &quot;getmessage&quot;.&nbsp;&nbsp;That way, for every imported function used, you know what<br>
script it was imported from.&nbsp;&nbsp;If you import several scripts each of them could<br>
define a GetMessage() function:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import &quot;../lib/getmessage.vim&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import &quot;../lib/getother.vim&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=1 ShowMessage echomsg getmessage.GetMessage(&lt;f-args&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=1 ShowOther echomsg getother.GetMessage(&lt;f-args&gt;)</div>
<br>
If the imported script name is long or you use it in many places, you can<br>
shorten it by adding an &quot;as&quot; argument:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import &quot;../lib/getmessage.vim&quot; as msg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=1 ShowMessage echomsg msg.GetMessage(&lt;f-args&gt;)</div>
<br>
<br>
RELOADING<br>
<br>
One thing to keep in mind: the imported &quot;lib/getmessage.vim&quot; script will be<br>
sourced only once.&nbsp;&nbsp;When it is imported a second time sourcing it will be<br>
skipped, since the items in it have already been created.&nbsp;&nbsp;It does not matter<br>
if this import command is in another script, or in the same script that is<br>
sourced again.<br>
<br>
This is efficient when using a plugin, but when still developing a plugin it<br>
means that changing &quot;lib/getmessage.vim&quot; after it has been imported will have<br>
no effect.&nbsp;&nbsp;You need to quit Vim and start it again. (Rationale: the items<br>
defined in the script could be used in a compiled function, sourcing the<br>
script again may break those functions).<br>
<br>
<br>
USING GLOBALS<br>
<br>
Sometimes you will want to use global variables or functions, so that they can<br>
be used anywhere.&nbsp;&nbsp;A good example is a global variable that passes a<br>
preference to a plugin.&nbsp;&nbsp;To avoid other scripts using the same name, use a<br>
prefix that is very unlikely to be used elsewhere.&nbsp;&nbsp;For example, if you have a<br>
&quot;mytags&quot; plugin, you could use:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:mytags_location = '$HOME/project'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:mytags_style = 'fast'</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.2" name="52.2">52.2</a>&nbsp;&nbsp;Autoloading<br>
<br>
After splitting your large script into pieces, all the lines will still be<br>
loaded and executed the moment the script is used.&nbsp;&nbsp;Every&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;loads the<br>
imported script to find the items defined there.&nbsp;&nbsp;Although that is good for<br>
finding errors early, it also takes time.&nbsp;&nbsp;Which is wasted if the<br>
functionality is not often used.<br>
<br>
Instead of having&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;load the script immediately, it can be postponed<br>
until needed.&nbsp;&nbsp;Using the example above, only one change needs to be made in<br>
the plugin/theplugin.vim script:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import autoload &quot;../lib/getmessage.vim&quot;</div>
<br>
Nothing in the rest of the script needs to change.&nbsp;&nbsp;However, the types will<br>
not be checked.&nbsp;&nbsp;Not even the existence of the GetMessage() function is<br>
checked until it is used.&nbsp;&nbsp;You will have to decide what is more important for<br>
your script: fast startup or getting errors early.&nbsp;&nbsp;You can also add the<br>
&quot;autoload&quot; argument later, after you have checked everything works.<br>
<br>
<br>
AUTOLOAD DIRECTORY<br>
<br>
Another form is to use autoload with a script name that is not an absolute or<br>
relative path:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import autoload &quot;monthlib.vim&quot;</div>
<br>
This will search for the script &quot;monthlib.vim&quot; in the autoload directories of<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>.&nbsp;&nbsp;With Unix one of the directories often is &quot;~/.vim/autoload&quot;.<br>
It will also search under&nbsp;<a class="Type" href="options.html#'packpath'">'packpath'</a>, under &quot;start&quot;.<br>
<br>
The main advantage of this is that this script can be easily shared with other<br>
scripts.&nbsp;&nbsp;You do need to make sure that the script name is unique, since Vim<br>
will search all the &quot;autoload&quot; directories in&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>, and if you are<br>
using several plugins with a plugin manager, it may add a directory to<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>, each of which might have an &quot;autoload&quot; directory.<br>
<br>
Without autoload:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import &quot;monthlib.vim&quot;</div>
<br>
Vim will search for the script &quot;monthlib.vim&quot; in the import directories of<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>.&nbsp;&nbsp;<span class="Todo">Note</span>&nbsp;that in this case adding or removing &quot;autoload&quot; changes<br>
where the script is found.&nbsp;&nbsp;With a relative or absolute path the location does<br>
not change.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.3" name="52.3">52.3</a>&nbsp;&nbsp;Autoloading without import/export<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#write-library-script" name="write-library-script">write-library-script</a><br>
A mechanism from before import/export is still useful and some users may find<br>
it a bit simpler.&nbsp;&nbsp;The idea is that you call a function with a special name.<br>
That function is then in an autoload script.&nbsp;&nbsp;We will call that one script a<br>
library script.<br>
<br>
The autoload mechanism is based on a function name that has &quot;#&quot; characters:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mylib#myfunction(arg)</div>
<br>
Vim will recognize the function name by the embedded &quot;#&quot; character and when<br>
it is not defined yet search for the script &quot;autoload/mylib.vim&quot; in<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>.&nbsp;&nbsp;That script must define the &quot;mylib#myfunction()&quot; function.<br>
Obviously the name &quot;mylib&quot; is the part before the &quot;#&quot; and is used as the name<br>
of the script, adding &quot;.vim&quot;.<br>
<br>
You can put many other functions in the mylib.vim script, you are free to<br>
organize your functions in library scripts.&nbsp;&nbsp;But you must use function names<br>
where the part before the '#' matches the script name.&nbsp;&nbsp;Otherwise Vim would<br>
not know what script to load.&nbsp;&nbsp;This is where it differs from the import/export<br>
mechanism.<br>
<br>
If you get really enthusiastic and write lots of library scripts, you may<br>
want to use subdirectories.&nbsp;&nbsp;Example:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netlib#ftp#read('somefile')</div>
<br>
Here the script name is taken from the function name up to the last &quot;#&quot;. The<br>
&quot;#&quot; in the middle are replaced by a slash, the last one by &quot;.vim&quot;.&nbsp;&nbsp;Thus you<br>
get &quot;netlib/ftp.vim&quot;.&nbsp;&nbsp;For Unix the library script used for this could be:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~/.vim/autoload/netlib/ftp.vim<br>
<br>
Where the function is defined like this:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def netlib#ftp#read(fname: string)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;Read the file fname through ftp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
Notice that the name the function is defined with is exactly the same as the<br>
name used for calling the function.&nbsp;&nbsp;And the part before the last '#'<br>
exactly matches the subdirectory and script name.<br>
<br>
You can use the same mechanism for variables:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var weekdays = dutch#weekdays</div>
<br>
This will load the script &quot;autoload/dutch.vim&quot;, which should contain something<br>
like:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ 'donderdag', 'vrijdag', 'zaterdag']</div>
<br>
Further reading:&nbsp;<a class="Identifier" href="userfunc.html#autoload">autoload</a>.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.4" name="52.4">52.4</a>&nbsp;&nbsp;Other mechanisms to use<br>
<br>
Some may find the use of several files a hassle and prefer to keep everything<br>
together in one script.&nbsp;&nbsp;To avoid this resulting in slow startup there is a<br>
mechanism that only defines a small part and postpones the rest to when it is<br>
actually used.&nbsp;&nbsp;<a class="Constant" href="usr_52.html#write-plugin-quickload" name="write-plugin-quickload">write-plugin-quickload</a><br>
<br>
The basic idea is that the plugin is loaded twice.&nbsp;&nbsp;The first time user<br>
commands and mappings are defined that offer the functionality.&nbsp;&nbsp;The second<br>
time the functions that implement the functionality are defined.<br>
<br>
It may sound surprising that quickload means loading a script twice.&nbsp;&nbsp;What we<br>
mean is that it loads quickly the first time, postponing the bulk of the<br>
script to the second time, which only happens when you actually use it.&nbsp;&nbsp;When<br>
you always use the functionality it actually gets slower!<br>
<br>
This uses a FuncUndefined autocommand.&nbsp;&nbsp;This works differently from the<br>
<a class="Identifier" href="userfunc.html#autoload">autoload</a>&nbsp;functionality explained above.<br>
<br>
The following example shows how it's done:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Vim global plugin for demonstrating quick loading<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Last Change:&nbsp;&nbsp;2005 Feb 25<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;s:did_load&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=* BNRead&nbsp;&nbsp;call BufNetRead(&lt;f-args&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let s:did_load = 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exe 'au FuncUndefined BufNet* source ' .. expand('&lt;sfile&gt;')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetRead(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetRead(' .. string(a:000) .. ')'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; read functionality here<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetWrite(...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetWrite(' .. string(a:000) .. ')'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; write functionality here<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</div>
<br>
When the script is first loaded &quot;s:did_load&quot; is not set.&nbsp;&nbsp;The commands between<br>
the &quot;if&quot; and &quot;endif&quot; will be executed.&nbsp;&nbsp;This ends in a&nbsp;<a class="Identifier" href="repeat.html#:finish">:finish</a>&nbsp;command, thus<br>
the rest of the script is not executed.<br>
<br>
The second time the script is loaded &quot;s:did_load&quot; exists and the commands<br>
after the &quot;endif&quot; are executed.&nbsp;&nbsp;This defines the (possible long)<br>
BufNetRead() and BufNetWrite() functions.<br>
<br>
If you drop this script in your plugin directory Vim will execute it on<br>
startup.&nbsp;&nbsp;This is the sequence of events that happens:<br>
<br>
1. The &quot;BNRead&quot; command is defined and the&nbsp;<span class="Special">&lt;F19&gt;</span>&nbsp;key is mapped when the script<br>
&nbsp;&nbsp; is sourced at startup.&nbsp;&nbsp;A&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;autocommand is defined.&nbsp;&nbsp;The<br>
&nbsp;&nbsp; &quot;:finish&quot; command causes the script to terminate early.<br>
<br>
2. The user types the BNRead command or presses the&nbsp;<span class="Special">&lt;F19&gt;</span>&nbsp;key.&nbsp;&nbsp;The<br>
&nbsp;&nbsp; BufNetRead() or BufNetWrite() function will be called.<br>
<br>
3. Vim can't find the function and triggers the&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;autocommand<br>
&nbsp;&nbsp; event.&nbsp;&nbsp;Since the pattern &quot;BufNet*&quot; matches the invoked function, the<br>
&nbsp;&nbsp; command &quot;source fname&quot; will be executed.&nbsp;&nbsp;&quot;fname&quot; will be equal to the name<br>
&nbsp;&nbsp; of the script, no matter where it is located, because it comes from<br>
&nbsp;&nbsp; expanding &quot;<span class="Special">&lt;sfile&gt;</span>&quot; (see&nbsp;<a class="Identifier" href="builtin.html#expand()">expand()</a>).<br>
<br>
4. The script is sourced again, the &quot;s:did_load&quot; variable exists and the<br>
&nbsp;&nbsp; functions are defined.<br>
<br>
Notice that the functions that are loaded afterwards match the pattern in the<br>
<a class="Identifier" href="autocmd.html#FuncUndefined">FuncUndefined</a>&nbsp;autocommand.&nbsp;&nbsp;You must make sure that no other plugin defines<br>
functions that match this pattern.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_52.html#52.5" name="52.5">52.5</a>&nbsp;&nbsp;Using a Vim9 script from legacy script&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_52.html#source-vim9-script" name="source-vim9-script">source-vim9-script</a><br>
<br>
In some cases you have a legacy Vim script where you want to use items from a<br>
Vim9 script.&nbsp;&nbsp;For example in your .vimrc you want to initialize a plugin.&nbsp;&nbsp;The<br>
best way to do this is to use&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>.&nbsp;&nbsp;For example:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import 'myNicePlugin.vim'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call myNicePlugin.NiceInit('today')</div>
<br>
This finds the exported function &quot;NiceInit&quot; in the Vim9 script file and makes<br>
it available as script-local item &quot;myNicePlugin.NiceInit&quot;.&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;always<br>
uses the script namespace, even when &quot;s:&quot; is not given.&nbsp;&nbsp;If &quot;myNicePlugin.vim&quot;<br>
was already sourced it is not sourced again.<br>
<br>
Besides avoiding putting any items in the global namespace (where name clashes<br>
can cause unexpected errors), this also means the script is sourced only once,<br>
no matter how many times items from it are imported.<br>
<br>
In some cases, e.g. for testing, you may just want to source the Vim9 script.<br>
That is OK, but then only global items will be available.&nbsp;&nbsp;The Vim9 script<br>
will have to make sure to use a unique name for these global items. Example:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source ~/.vim/extra/myNicePlugin.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call g:NicePluginTest()</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
Next chapter:&nbsp;<a class="Identifier" href="usr_90.html">usr_90.txt</a>&nbsp;&nbsp;Installing Vim<br>
<br>
<br>
Copyright: see&nbsp;<a class="Identifier" href="usr_01.html#manual-copyright">manual-copyright</a>&nbsp;&nbsp;vim:tw=78:ts=8:noet:ft=help:norl:<br>
</div>
